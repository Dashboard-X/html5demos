// Generated by CoffeeScript 1.6.2
(function() {
  var applyConv, calcIntersect, getRGB, matrix;

  this.addEventListener('message', function(e) {
    this.rgba = e.data.rgba;
    this.imgwidth = e.data.width;
    this.imgheight = e.data.height;
    this.id = e.data.id;
    this.start = e.data.start;
    this.end = e.data.end;
    this.effect = e.data.effect;
    return this.postMessage({
      id: this.id,
      start: this.start,
      end: this.end,
      buffer: applyConv()
    });
  }, false);

  matrix = {
    blur: [[1, 2, 1], [2, 4, 2], [1, 2, 1]],
    sharpen: [[0, -1, 0], [-1, 5, -1], [0, -1, 0]],
    sharpen2: [[0, -2, 0], [-2, 11, -2], [0, -2, 0]],
    edge: [[0, 1, 0], [1, -4, 1], [0, 1, 0]],
    edge_enanche: [[0, 0, 0], [-1, 1, 0], [0, 0, 0]],
    edge_detect: [[0, 1, 0], [1, -4, 1], [0, 1, 0]],
    edge_detect2: [[1, 1, 1], [1, -7, 1], [1, 1, 1]],
    edge_detect3: [[-5, 0, 0], [0, 0, 0], [0, 0, 5]],
    emboss: [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]],
    emboss_subtle: [[1, 1, -1], [1, 3, -1], [1, -1, -1]],
    gaussian: [[1, 2, 1], [2, 4, 2], [1, 2, 1]],
    mean: [[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]]
  };

  calcIntersect = function(mat1, mat2) {
    var tot, x, y, _i, _j;

    tot = 0;
    for (y = _i = 0; _i < 3; y = ++_i) {
      for (x = _j = 0; _j < 3; x = ++_j) {
        tot += mat1[y][x] * mat2[y][x];
      }
    }
    return tot;
  };

  getRGB = function(x, y, c) {
    var index;

    index = (y * imgwidth + x) * 4;
    return rgba[index + c];
  };

  applyConv = function() {
    var allc, allpixel, c, i, max, nc, pixelval, singlepixel, x, y, _i, _j, _k, _l, _m, _n;

    allc = [[], [], []];
    max = [];
    singlepixel = [[], [], []];
    allpixel = [];
    for (y = _i = 0; 0 <= imgheight ? _i < imgheight : _i > imgheight; y = 0 <= imgheight ? ++_i : --_i) {
      for (x = _j = 0; 0 <= imgwidth ? _j < imgwidth : _j > imgwidth; x = 0 <= imgwidth ? ++_j : --_j) {
        for (c = _k = 0; _k <= 2; c = ++_k) {
          pixelval = calcIntersect([[getRGB(x - 1, y - 1, c), getRGB(x, y - 1, c), getRGB(x + 1, y - 1, c)], [getRGB(x - 1, y, c), getRGB(x, y, c), getRGB(x + 1, y, c)], [getRGB(x - 1, y, c), getRGB(x, y, c), getRGB(x + 1, y, c)]], matrix[this.effect]);
          if (pixelval > max[c] || !max[c]) {
            max[c] = pixelval;
          }
          allc[c].push(pixelval);
        }
      }
    }
    i = 0;
    for (y = _l = 0; 0 <= imgheight ? _l < imgheight : _l > imgheight; y = 0 <= imgheight ? ++_l : --_l) {
      for (x = _m = 0; 0 <= imgwidth ? _m < imgwidth : _m > imgwidth; x = 0 <= imgwidth ? ++_m : --_m) {
        for (nc = _n = 0; _n <= 2; nc = ++_n) {
          singlepixel[nc] = 255 * allc[nc][i] / max[nc] > 0 ? parseInt(255 * allc[nc][i] / max[nc]) : 0;
        }
        allpixel.push(singlepixel[0], singlepixel[1], singlepixel[2], 255);
        i++;
      }
    }
    return allpixel;
  };

}).call(this);

/*
//@ sourceMappingURL=uok.map
*/
